<#
    bool hasStringKeyComponent;

    hasStringKeyComponent = !string.IsNullOrWhiteSpace(keyName);
    #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:<#=Environment.Version.ToString() #>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;

// Copyright (c) 2017 Cyotek Ltd.
// http://mantissharp.net/
// Licensed under the MIT License. See LICENSE.txt for the full text.

// If you use this control in your applications, attribution, donations or contributions are welcome.

namespace MantisSharp
{
  public class <#=className #> : ICollection<<#=itemType #>>
  {
    #region Constants

    private readonly Dictionary<int, int> _indexesById;

<# if (hasStringKeyComponent)
    {
      #>
    private readonly Dictionary<string, int> _indexesByName;
<#
    } #>

    private readonly IList<<#=itemType #>> _items;

    #endregion

    #region Constructors

    public <#=className #>()
    {
<# if (hasStringKeyComponent)
    {
      #>
      _indexesByName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
<#
    } #>
      _indexesById = new Dictionary<int, int>();
      _items = new List<<#=itemType #>>();
    }

    #endregion

    #region Properties

<# if (hasStringKeyComponent)
    {
      #>
    public <#=itemType #> this[string key]
    {
      get
      {
        int index;

        if (!_indexesByName.TryGetValue(key, out index))
        {
          throw new KeyNotFoundException(string.Format("Cannot find key '{0}'.", key));
        }

        return _items[index];
      }
    }
<#
    } #>

    public <#=itemType #> this[int key]
    {
      get
      {
        int index;

        if (!_indexesById.TryGetValue(key, out index))
        {
          throw new KeyNotFoundException(string.Format("Cannot find key {0}.", key));
        }

        return _items[index];
      }
    }

    #endregion

    #region Methods

<# if (hasStringKeyComponent)
    {
      #>
    public bool ContainsKey(string key)
    {
      return _indexesByName.ContainsKey(key);
    }
<#
    } #>

    public bool ContainsKey(int key)
    {
      return _indexesById.ContainsKey(key);
    }

<# if (hasStringKeyComponent)
    {
      #>
    public bool TryGetValue(string key, out <#=itemType #> value)
    {
      int index;

      if (_indexesByName.TryGetValue(key, out index))
      {
        value = _items[index];
      }
      else
      {
        index = -1;
        value = null;
      }

      return index != -1;
    }
<#
    } #>

    public bool TryGetValue(int key, out <#=itemType #> value)
    {
      int index;

      if (_indexesById.TryGetValue(key, out index))
      {
        value = _items[index];
      }
      else
      {
        index = -1;
        value = null;
      }

      return index != -1;
    }

    internal void Add(<#=itemType #> item)
    {
<# if (hasStringKeyComponent)
    {
      #>
      string name;
<#
    } #>
      int index;

      if (item == null)
      {
        throw new ArgumentNullException(nameof(item));
      }

<# if (hasStringKeyComponent)
    {
      #>
      name = item.<#=keyName #>;

#if NET35
      if (string.IsNullOrEmpty(name))
#else
      if (string.IsNullOrWhiteSpace(name))
#endif
      {
        throw new ArgumentException("Unnamed items cannot be added.", nameof(item));
      }

      if (_indexesByName.ContainsKey(name))
      {
        throw new ArgumentNullException(string.Format("An item with key '{0}' already exists.", name), nameof(item));
      }
<#
    } #>

      _items.Add(item);

      index = _items.Count - 1;

<# if (hasStringKeyComponent)
    {
      #>
      _indexesByName.Add(name, index);
<#
    } #>
      _indexesById.Add(item.Id, index);
    }

    internal void Clear()
    {
      _indexesById.Clear();
<# if (hasStringKeyComponent)
    {
      #>
      _indexesByName.Clear();
<#
    } #>
      _items.Clear();
    }

    internal bool Remove(<#=itemType #> item)
    {
<# if (hasStringKeyComponent)
    {
      #>
      return this.Remove(item.<#=keyName #>);
<#
    }
    else
    {
      #>
      return false;
<#
    } #>
    }

<# if (hasStringKeyComponent)
    {
      #>
    internal bool Remove(string key)
    {
      int index;

      if (_indexesByName.TryGetValue(key, out index))
      {
        _indexesByName.Remove(key);
        _items.RemoveAt(index);
      }
      else
      {
        index = -1;
      }

      return index != -1;
    }
<#
    } #>

    #endregion

    #region ICollection<<#=itemType #>> Interface

    public bool Contains(<#=itemType #> item)
    {
      return this.ContainsKey(item.Id);
    }

    public void CopyTo(<#=itemType #>[] array, int arrayIndex)
    {
      _items.CopyTo(array, arrayIndex);
    }

    public IEnumerator<<#=itemType #>> GetEnumerator()
    {
      return _items.GetEnumerator();
    }

    void ICollection<<#=itemType #>>.Add(<#=itemType #> item)
    {
      this.Add(item);
    }

    void ICollection<<#=itemType #>>.Clear()
    {
      this.Clear();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
      return this.GetEnumerator();
    }

    bool ICollection<<#=itemType #>>.Remove(<#=itemType #> item)
    {
      return this.Remove(item);
    }

    public int Count
    {
      get { return _items.Count; }
    }

    bool ICollection<<#=itemType #>>.IsReadOnly
    {
      get { return false; }
    }

    #endregion
  }
}
